#!/usr/bin/env python
# -*- mode:python; tab-width:4; indent-tabs-mode:nil; -*-
# ex: filetype=python tabstop=4 softtabstop=4 shiftwidth=4 expandtab autoindent smartindent

#
# GPS to Logbook data converter
# Author: Cedric Dufour <http://cedric.dufour.name>
#
# The GPS to Logbook data converter is free software:
# you can redistribute it and/or modify it *as you wish*.
# Maintaining the author(s) acknowledgment would be nice, though ;-)
#
# The GPS to Logbook data converter is distributed in the hope
# that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#


# Modules
# ... deb: python-argparse, python-dateutil, python-matplotlib, python-numpy, python-opencv, python-scipy
import argparse
import csv
import cv2
from dateutil import parser
import math
import matplotlib.pyplot as plot
import numpy
from scipy import interpolate
import time
import textwrap
import sys


#------------------------------------------------------------------------------
# CONSTANTS
#------------------------------------------------------------------------------

# Geodesical constants (shamelessly copied from GPSD)
GPS_PI = 3.1415926535897932384626433832795029
RAD_2_DEG = 57.2957795130823208767981548141051703
DEG_2_RAD = 0.0174532925199432957692369076848861271
WGS84A = 6378137 # equatorial radius
WGS84B = 6356752.3142 # polar radius


#------------------------------------------------------------------------------
# FUNCTIONS
#------------------------------------------------------------------------------

def trackRL( _fLat1, _fLon1, _fLat2, _fLon2 ):
    """
    Loxodrome (rhumb line) track (distance, bearing) between two geographical points.
    """

    # Units conversion
    _fLat1 *= DEG_2_RAD
    _fLon1 *= DEG_2_RAD
    _fLat2 *= DEG_2_RAD
    _fLon2 *= DEG_2_RAD

    # Formula shamelessly copied from http://www.movable-type.co.uk/scripts/latlong.html
    __fLatD = _fLat2 - _fLat1
    __fLonD = _fLon2 - _fLon1
    __fPhiD = math.log( math.tan( _fLat2/2.0 + GPS_PI/4.0 ) / math.tan( _fLat1/2.0 + GPS_PI/4.0 ) )
    try:
        __fQ = __fLatD / __fPhiD
    except ZeroDivisionError:
        __fQ = math.cos( _fLat1 )
    if abs( __fLonD ) > GPS_PI:
        if __fLonD > 0.0:
            __fLonD = __fLonD - GPS_PI*2.0
        else:
            __fLonD = GPS_PI*2.0 + __fLonD
    __fDistance = ( WGS84A + WGS84B ) / 2.0 * math.sqrt( __fLatD*__fLatD + __fLonD*__fLonD * __fQ*__fQ )
    __fBearing = math.atan2( __fLonD, __fPhiD )
    __fBearing *= RAD_2_DEG
    if __fBearing < 0:
        __fBearing += 360.0
    return ( __fDistance, __fBearing )


def destinationRL( _fLat1, _fLon1, _fBrng, _fDist ):
    """
    Loxodrome (rhumb line) desptination point from given geographical point along given course.
    """

    # Units conversion
    _fLat1 *= DEG_2_RAD
    _fLon1 *= DEG_2_RAD
    _fBrng *= DEG_2_RAD

    # Formula shamelessly copied from http://www.movable-type.co.uk/scripts/latlong.html
    __fLatD = _fDist * math.cos( _fBrng )
    __fLat2 = _fLat1 + __fLatD
    __fPhiD = math.log( math.tan( __fLat2/2.0 + GPS_PI/4.0 ) / math.tan( _fLat1/2.0 + GPS_PI/4.0 ) )
    try:
        __fQ = __fLatD / __fPhiD
    except ZeroDivisionError:
        __fQ = math.cos( _fLat1 )
    __fLonD = _fDist * math.sin( _fBrng ) / __fQ
    if math.abs( __fLat2 ) > GPS_PI/2.0:
        if __fLat2 > 0.0:
            __fLat2 = GPS_PI - __fLat2
        else:
            __fLat2 = - GPS_PI - __fLat2
    __fLon2 = ( _fLon1 + __fLonD +GPS_PI ) % ( GPS_PI*2.0 ) - GPS_PI;
    return ( __fLat2 * RAD_2_DEG, __fLon2 * RAD_2_DEG )


def midpointRL( _fLat1, _fLon1, _fLat2, _fLon2 ):
    """
    Loxodrome (rhumb line) midpoint between two geographical points.
    """

    # Units conversion
    _fLat1 *= DEG_2_RAD
    _fLon1 *= DEG_2_RAD
    _fLat2 *= DEG_2_RAD
    _fLon2 *= DEG_2_RAD

    if abs( _fLon2 - _fLon1 ) > GPS_PI:
        _fLon1 += 2*GPS_PI

    # Formula shamelessly copied from http://www.movable-type.co.uk/scripts/latlong.html
    __fLat3 = ( _fLat1 + _fLat2 ) / 2.0;
    __f1 = math.tan( _fLat1/2.0 + GPS_PI/4.0 );
    __f2 = math.tan( _fLat2/2.0 + GPS_PI/4.0 );
    __f3 = math.tan( __fLat3/2.0 + GPS_PI/4.0 );
    try:
        __fLon3 = ( ( _fLon2 - _fLon1 )*math.log( __f3 ) + _fLon1*math.log( __f2 ) - _fLon2*math.log( __f1 ) ) / math.log( __f2/__f1 )
    except ZeroDivisionError:
        __fLon3 = ( _fLon1 + _fLon2 ) / 2.0
    __fLon3 = ( __fLon3 + GPS_PI*3.0 ) % ( GPS_PI*2.0 ) - GPS_PI
    return ( __fLat3 * RAD_2_DEG, __fLon3 * RAD_2_DEG )


def skeleton( _aArray, _iMaxN ):
    __aSkeleton = numpy.zeros( numpy.shape( _aArray ), numpy.uint8 )
    __aK = numpy.ones( 3, numpy.uint8 )
    for __i in range(0,_iMaxN+1):
        __aKN = numpy.ones( 2*__i+1, numpy.uint8 )
        __aErode = cv2.erode( _aArray, __aKN )
        __aSkeleton = __aSkeleton + __aErode - cv2.morphologyEx( __aErode, cv2.MORPH_OPEN, __aK )
    return __aSkeleton



#------------------------------------------------------------------------------
# CLASSES
#------------------------------------------------------------------------------

# GPS data container
class CGpsData:

    #------------------------------------------------------------------------------
    # CONSTRUCTORS / DESTRUCTOR
    #------------------------------------------------------------------------------

    def __init__( self ):
        self.reset()

    def reset( self ):
        self.iTrigCount = 0
        self.fTrigEpoch = 0.0
        self.bDataFill = False
        self.bDataProcessed = False
        self.iDataLength = 0
        self.fEpochPrev = 0.0
        self.fLatPrev = 0.0
        self.fLonPrev = 0.0
        self.lEpoch = []
        self.lLat = []
        self.lLon = []
        self.lEle = []
        self.lLatErr = []
        self.lLonErr = []
        self.lEleErr = []


# GPS to Logbook data converter class
class CGps2Logbook:
    """
    GPS to Logbook
    """

    #------------------------------------------------------------------------------
    # CONSTRUCTORS / DESTRUCTOR
    #------------------------------------------------------------------------------

    def __init__( self ):
       # Variables
        self.oArgumentParser = None
        self.oArguments = None
        self.fRwyLat = None,
        self.fRwyLon = None,
        self.fRwyLength = None,
        self.fRwyHeading = None,
        self.iNoiseFilterLength = None
        self.aNoiseFilterKernel = None
        self.iTouchgoFilterLength = None
        self.aTouchgoFilterKernel = None
        self.__initArgumentParser()


    def __initArgumentParser( self ):
        """
        Creates the arguments parser (and help generator)
        """

        # Create argument parser
        self.oArgumentParser = argparse.ArgumentParser( prog=sys.argv[0].split('/')[-1],
            formatter_class = argparse.RawDescriptionHelpFormatter,
            description = 'GPS to Logbook data converter',
            epilog = textwrap.dedent( '''\
                Input file (DSV) fields:

                  Id,Time,Lat[deg],Lon[deg],Ele[m],LatErr[m],LonErr[m],EleErr[m]
                  [or]
                  Id,Time,Lat[deg],Lon[deg],Ele[m]
                ''' ) )

        # ... input file
        # self.oArgumentParser.add_argument( 'gps_data_file', type=str,
        #                                    default='stdin',
        #                                    metavar='<path>',
        #                                    help='GPS data (DSV) file' )

        # ... 1st runway threshold latitude
        self.oArgumentParser.add_argument( '-Rlat1', '--runway_threshold_latitude_1', type=float,
                                           default=-999,
                                           metavar='<latitude>',
                                           help='1st runway threshold latitude, in degrees [deg]' )

        # ... 1st runway threshold longitude
        self.oArgumentParser.add_argument( '-Rlon1', '--runway_threshold_longitude_1', type=float,
                                           default=-999,
                                           metavar='<longitude>',
                                           help='1st runway threshold longitude, in degrees [deg]' )

        # ... 1st runway threshold elevation
        self.oArgumentParser.add_argument( '-Rele1', '--runway_threshold_elevation_1', type=float,
                                           default=-999,
                                           metavar='<elevation>',
                                           help='1st runway threshold, in meters [m]' )

        # ... 2nd runway threshold latitude
        self.oArgumentParser.add_argument( '-Rlat2', '--runway_threshold_latitude_2', type=float,
                                           default=-999,
                                           metavar='<latitude>',
                                           help='2nd runway threshold latitude, in degrees [deg]' )

        # ... 2nd runway threshold longitude
        self.oArgumentParser.add_argument( '-Rlon2', '--runway_threshold_longitude_2', type=float,
                                           default=-999,
                                           metavar='<longitude>',
                                           help='2nd runway threshold longitude, in degrees [deg]' )

        # ... 2nd runway threshold elevation
        self.oArgumentParser.add_argument( '-Rele2', '--runway_threshold_elevation_2', type=float,
                                           default=-999,
                                           metavar='<elevation>',
                                           help='2nd runway threshold, in meters [m]' )

        # ... runway width
        self.oArgumentParser.add_argument( '-Rw', '--runway_width', type=float,
                                           default=-999,
                                           metavar='<width>',
                                           help='Runway width, in meters [m]' )

        # ... stall speed (landing)
        self.oArgumentParser.add_argument( '-Vs0', '--stall_speed_landing', type=float,
                                           default=15.0,
                                           metavar='<speed:15.0>',
                                           help='Aircraft stall speed (landing, Vs0), in meters per second [m/s]' )


        # ... stall speed (take-off)
        self.oArgumentParser.add_argument( '-Vs1', '--stall_speed_takeoff', type=float,
                                           default=25.0,
                                           metavar='<speed:25.0>',
                                           help='Aircraft stall speed (take-off, Vs1), in meters per second [m/s]' )

        # ... wind speed
        self.oArgumentParser.add_argument( '-Ws', '--wind_speed', type=float,
                                           default=0,
                                           metavar='<speed:0>',
                                           help='Wind speed, in meters per second [m/s]' )

        # ... wind direction
        self.oArgumentParser.add_argument( '-Wd', '--wind_direction', type=float,
                                           default=0,
                                           metavar='<angle:0>',
                                           help='Wind direction, in degrees [deg]' )

        # ... analysis windows length
        self.oArgumentParser.add_argument( '-La', '--analysis_length', type=float,
                                           default=300.0,
                                           metavar='<seconds:300.0>',
                                           help='Analysis window length, in seconds [s]' )

        # ... noise filter length
        self.oArgumentParser.add_argument( '-Ln', '--noise_filter', type=float,
                                           default=5.0,
                                           metavar='<seconds:5.0>',
                                           help='Noise filter length, in seconds [s]' )

        # ... touch-n-go filter length
        self.oArgumentParser.add_argument( '-Ltg', '--touchgo_filter', type=float,
                                           default=60.0,
                                           metavar='<seconds:30.0>',
                                           help='Touch-\'n-Go filter length, in seconds [s]' )

        # ... delimiter
        self.oArgumentParser.add_argument( '-d', '--delimiter', type=str,
                                           default=',',
                                           metavar='<character:\',\'>',
                                           help='GPS data (DSV) file delimiter' )

        # ... time resolution
        self.oArgumentParser.add_argument( '--time_resolution', type=float,
                                           default=0.1,
                                           metavar='<seconds:0.1>',
                                           help='Time resolution, in seconds [s]' )

        # ... maximum horizontal acceleration
        self.oArgumentParser.add_argument( '--max_horz_acceleration', type=float,
                                           default=5.0,
                                           metavar='<acceleration:5.0>',
                                           help='Maximum horizontal acceleration, in meters per square second [m/s^2]' )

        # ... maximum vertical acceleration
        self.oArgumentParser.add_argument( '--max_vert_acceleration', type=float,
                                           default=2.5,
                                           metavar='<acceleration:2.5>',
                                           help='Maximum vertical acceleration, in meters per square second [m/s^2]' )

        # ... debug
        self.oArgumentParser.add_argument( '--debug', action='store_true',
                                           default=False,
                                           help='Show debugging information' )



    def __initArguments( self, _aArguments = None ):
        """
        Parses the command-line arguments; returns a non-zero exit code in case of failure.
        """

        # Parse arguments
        if _aArguments is None:
            _aArguments = sys.argv
        try:
            self.oArguments = self.oArgumentParser.parse_args()
        except Exception, e:
            self.oArguments = None
            sys.stderr.write( 'ERROR: Failed to parse arguments; %s\n' % str(e) )
            return 1

        # Validate arguments
        # if len( self.oArguments.gps_data_file ) <= 0:
        #     sys.stderr.write( 'ERROR: Missing GPS data file path (gps_data_file); %s\n' % str(e) )
        #     return 1
        if self.oArguments.runway_threshold_latitude_1 < -90 or self.oArguments.runway_threshold_latitude_1 > 90:
            sys.stderr.write( 'ERROR: Missing or invalid 1st runway threshold latitude (runway_threshold_latitude_1)\n' )
            return 1
        if self.oArguments.runway_threshold_longitude_1 < -180 or self.oArguments.runway_threshold_longitude_1 > 180:
            sys.stderr.write( 'ERROR: Missing or invalid 1st runway threshold longitude (runway_threshold_longitude_1)\n' )
            return 1
        if self.oArguments.runway_threshold_elevation_1 < 0:
            sys.stderr.write( 'ERROR: Missing or invalid 1st runway threshold elevation (runway_threshold_elevation_1)\n' )
            return 1
        if self.oArguments.runway_threshold_latitude_2 < -90 or self.oArguments.runway_threshold_latitude_2 > 90:
            sys.stderr.write( 'ERROR: Missing or invalid 2nd runway threshold latitude (runway_threshold_latitude_2)\n' )
            return 1
        if self.oArguments.runway_threshold_longitude_2 < -180 or self.oArguments.runway_threshold_longitude_2 > 180:
            sys.stderr.write( 'ERROR: Missing or invalid 2nd runway threshold longitude (runway_threshold_longitude_2)\n' )
            return 1
        if self.oArguments.runway_threshold_elevation_2 < 0:
            sys.stderr.write( 'ERROR: Missing or invalid 2nd runway threshold elevation (runway_threshold_elevation_2)\n' )
            return 1
        if self.oArguments.runway_width < 0:
            sys.stderr.write( 'ERROR: Missing or invalid runway width (runway_width)\n' )
            return 1
        if self.oArguments.stall_speed_landing < 0:
            sys.stderr.write( 'ERROR: Invalid landing stall speed (stall_speed_landing)\n' )
            return 1
        if self.oArguments.stall_speed_takeoff < 0:
            sys.stderr.write( 'ERROR: Invalid takeoff stall speed (stall_speed_takeoff)\n' )
            return 1
        if self.oArguments.analysis_length < 30:
            sys.stderr.write( 'ERROR: Invalid analysis window length (analysis_length)\n' )
            return 1
        if self.oArguments.touchgo_filter < 1:
            sys.stderr.write( 'ERROR: Invalid noise filter length (noise_filter)\n' )
            return 1
        if self.oArguments.touchgo_filter < self.oArguments.noise_filter:
            sys.stderr.write( 'ERROR: Invalid Touch-\'n-Go filter length (touchgo_filter)\n' )
            return 1
        if self.oArguments.time_resolution < 0.1 or self.oArguments.time_resolution > 1.0:
            sys.stderr.write( 'ERROR: Missing or invalid time resolution (time_resolution)\n' )
            return 1
        if self.oArguments.max_horz_acceleration < 0.1 or self.oArguments.max_horz_acceleration > 100.0:
            sys.stderr.write( 'ERROR: Missing or invalid maximum acceleration (max_horz_acceleration)\n' )
            return 1
        if self.oArguments.max_vert_acceleration < 0.1 or self.oArguments.max_vert_acceleration > 100.0:
            sys.stderr.write( 'ERROR: Missing or invalid maximum acceleration (max_vert_acceleration)\n' )
            return 1
        return 0


    #------------------------------------------------------------------------------
    # METHODS
    #------------------------------------------------------------------------------

    #
    # Processing
    #

    def __rwyele( self, _fLat, _fLon ):
        """
        Returns the runway elevation at the given geographical point.
        """

        ( __fThrDist, __fThrAzim ) = trackRL( self.oArguments.runway_threshold_latitude_1, self.oArguments.runway_threshold_longitude_1, _fLat, _fLon )
        return \
          self.oArguments.runway_threshold_elevation_1 + \
          ( self.oArguments.runway_threshold_elevation_2 - self.oArguments.runway_threshold_elevation_1 ) * \
          math.cos( ( self.fRwyHeading - __fThrAzim ) * DEG_2_RAD ) * __fThrDist / self.fRwyLength


    def __process( self, _sIdent, _oGpsData ):
        """
        Process the data window and output touchdown/airbone data.
        """

        if self.oArguments.debug:
            sys.stderr.write( "DEBUG[__process]: Aircraft = %s\n" % _sIdent )

        # Data length
        __iDataLength = len( _oGpsData.lEpoch )
        __lDataRange = range( __iDataLength )
        if self.oArguments.debug:
            sys.stderr.write( "DEBUG[__process]: GPS data time start = %s.%sZ\n" % \
                              ( time.strftime( '%Y-%m-%dT%H:%M:%S', time.gmtime( _oGpsData.lEpoch[0] ) ), ( "%.3f" % math.modf( _oGpsData.lEpoch[0] )[0])[2:] ) )
            sys.stderr.write( "DEBUG[__process]: GPS data timespan = %.1fs (N=%d)\n" % \
                              ( _oGpsData.lEpoch[__iDataLength-1]-_oGpsData.lEpoch[0], __iDataLength ) )

        # Interpolate data
        # NOTE: Objective is to obtain time-consistent data, matching the target time resolution
        #       No smoothing is applied yet (s=0)
        __aEpoch = numpy.arange( _oGpsData.lEpoch[0], _oGpsData.lEpoch[__iDataLength-1]+self.oArguments.time_resolution, self.oArguments.time_resolution )
        __iSplineLength = len( __aEpoch )
        __lSplineRange = range( __iSplineLength )
        if self.oArguments.debug:
            sys.stderr.write( "DEBUG[__process]: Interpolated data timespan = %.1fs (N=%d)\n" % \
                              ( __aEpoch[__iSplineLength-1]-__aEpoch[0], __iSplineLength ) )
        # ... latitude
        __tTCK = interpolate.splrep( _oGpsData.lEpoch, _oGpsData.lLat, k=3, s=0 )
        __aLat = interpolate.splev( __aEpoch, __tTCK, der=0 )
        # ... longitude
        __tTCK = interpolate.splrep( _oGpsData.lEpoch, _oGpsData.lLon, k=3, s=0 )
        __aLon = interpolate.splev( __aEpoch, __tTCK, der=0 )
        # ... elevation
        __tTCK = interpolate.splrep( _oGpsData.lEpoch, _oGpsData.lEle, k=3, s=0 )
        __aEle = interpolate.splev( __aEpoch, __tTCK, der=0 )
        # ... latitude error
        __tTCK = interpolate.splrep( _oGpsData.lEpoch, _oGpsData.lLatErr, k=3, s=0 )
        __aLatErr = interpolate.splev( __aEpoch, __tTCK, der=0 )
        # ... longitude error
        __tTCK = interpolate.splrep( _oGpsData.lEpoch, _oGpsData.lLonErr, k=3, s=0 )
        __aLonErr = interpolate.splev( __aEpoch, __tTCK, der=0 )
        # ... elevation error
        __tTCK = interpolate.splrep( _oGpsData.lEpoch, _oGpsData.lEleErr, k=3, s=0 )
        __aEleErr = interpolate.splev( __aEpoch, __tTCK, der=0 )

        # Compute altitude AGL and vertical speed
        # NOTE: This is a 1st pass; we shall compute an "altitude error profile" in a 2nd-pass
        #       Smoothing is applied, with a smoothing factor (s=...) adapted such as to match
        #       the target maximum acceleration constraint (iow. remain precise enough but get
        #       rid of transients/instabilities artefacts)
        __aAlt = numpy.zeros( __iSplineLength )
        for __i in __lSplineRange:
            __aAlt[__i] = __aEle[__i] - self.__rwyele( __aLat[__i], __aLon[__i] )
        # ... smoothing and derivation (speed)
        __aW3D = numpy.zeros( __iSplineLength )
        __fW3DTot = 0.0
        for __i in __lSplineRange:
            __aW3D[__i] = ( 150.0 - abs( __aEleErr[__i] ) ) / 150.0
            if __aW3D[__i] < 0.0: __aW3D[__i] = 0.0
            __fW3DTot += __aW3D[__i]
        __fError3D = 1 - __fW3DTot / __iSplineLength
        if self.oArguments.debug:
            sys.stderr.write( "DEBUG[__process]: 3D error factor = %f\n" % __fError3D )
        __fSmoothingFactor3D = 0.0
        for __n in range( 30 ):
            # ... look for a smoothing factor that keeps acceleration below specified limit
            __fSmoothingFactor3D = 100.0 / 10**((30.0-__n)/10.0)
            try:
                __tTCK = interpolate.splrep( __aEpoch, __aAlt, k=3, w=__aW3D, s=__iSplineLength*(__fSmoothingFactor3D*__fError3D)**2 )
                __aVAcc = interpolate.splev( __aEpoch, __tTCK, der=2 )
            except Exception:
                continue
            __fVAccMax = 0.0
            for __i in __lSplineRange:
                __fVAcc = abs( __aVAcc[__i] )
                if __fVAcc > __fVAccMax: __fVAccMax = __fVAcc
            if __fVAccMax <= self.oArguments.max_vert_acceleration:
                break
        if self.oArguments.debug:
            sys.stderr.write( "DEBUG[__process]: 3D smoothing factor = %f\n" % __fSmoothingFactor3D )
        __aAlt = interpolate.splev( __aEpoch, __tTCK, der=0 )
        __aVSpd = interpolate.splev( __aEpoch, __tTCK, der=1 )

        # Compute distance, bearing and horizontal speed
        # NOTE: Smoothing is applied, with a smoothing factor (s=...) adapted such as to match
        #       the target maximum acceleration constraint (iow. remain precise enough but get
        #       rid of transients/instabilities artefacts)
        __aDist = numpy.zeros( __iSplineLength )
        __aBrng = numpy.zeros( __iSplineLength )
        for __i in __lSplineRange[1:]:
            ( __fDist, __fBrng ) = trackRL( __aLat[__i-1], __aLon[__i-1], __aLat[__i], __aLon[__i] )
            __aDist[__i] = __aDist[__i-1] + __fDist
            __aBrng[__i] = __fBrng
        __aBrng[0] = __aBrng[1]
        # ... smoothing and derivation (speed)
        __aW2D = numpy.zeros( __iSplineLength )
        __fW2DTot = 0.0
        for __i in __lSplineRange:
            __fWLat = ( 100.0 - abs( __aLatErr[__i] ) ) / 100.0
            if __fWLat < 0.0: __fWLat = 0.0
            __fWLon = ( 100.0 - abs( __aLonErr[__i] ) ) / 100.0
            if __fWLon < 0.0: __fWLon = 0.0
            __aW2D[__i] = math.sqrt( ( __fWLat**2 + __fWLon**2 ) / 2.0 )
            __fW2DTot += __aW2D[__i]
        __fError2D = 1 - __fW2DTot / __iSplineLength
        if self.oArguments.debug:
            sys.stderr.write( "DEBUG[__process]: 2D error factor = %f\n" % __fError2D )
        __fSmoothingFactor2D = 0.0
        for __n in range( 30 ):
            # ... look for a smoothing factor that keeps acceleration below specified limit
            __fSmoothingFactor2D = 100.0 / 10**((30.0-__n)/10.0)
            try:
                __tTCK = interpolate.splrep( __aEpoch, __aDist, k=3, w=__aW2D, s=__iSplineLength*(__fSmoothingFactor2D*__fError2D)**2 )
                __aHAcc = interpolate.splev( __aEpoch, __tTCK, der=2 )
            except Exception:
                continue
            __fHAccMax = 0.0
            for __i in __lSplineRange:
                __fHAcc = abs( __aHAcc[__i] )
                if __fHAcc > __fHAccMax: __fHAccMax = __fHAcc
            if __fHAccMax <= self.oArguments.max_horz_acceleration:
                break
        if self.oArguments.debug:
            sys.stderr.write( "DEBUG[__process]: 2D smoothing factor = %f\n" % __fSmoothingFactor2D )
        __aDist = interpolate.splev( __aEpoch, __tTCK, der=0 )
        __aHSpd = interpolate.splev( __aEpoch, __tTCK, der=1 )
        __tTCK = interpolate.splrep( __aEpoch, __aBrng, k=3, w=__aW2D, s=__iSplineLength*(__fSmoothingFactor2D*__fError2D)**2 )
        __aBrng = interpolate.splev( __aEpoch, __tTCK, der=0 )
        # ... correct wind speed
        for __i in range( __iSplineLength ):
            __aHSpd[__i] += self.oArguments.wind_speed * math.cos( ( __aBrng[__i] - self.oArguments.wind_direction ) * DEG_2_RAD )

        # Check distance and altitude span
        # NOTE: This allows to get rid of aircrafts:
        #        1. moving on the ground
        #        2. making low-altitude passes
        #       in the vicinity of the runway
        __fDistMin = 9999999.0
        __fDistMax = -9999999.0
        __fAltMin = 9999999.0
        __fAltMax = -9999999.0
        for __i in __lSplineRange:
            __fDist = __aDist[__i]
            if __fDist < __fDistMin: __fDistMin = __fDist
            if __fDist > __fDistMax: __fDistMax = __fDist
            __fAlt = __aAlt[__i]
            if __fAlt < __fAltMin: __fAltMin = __fAlt
            if __fAlt > __fAltMax: __fAltMax = __fAlt
        if self.oArguments.debug:
            sys.stderr.write( "DEBUG[__process]: Distance span = %.1f / Altitude span = %.1f\n" % ( __fDistMax - __fDistMin, __fAltMax - __fAltMin ) )
        if __fDistMax - __fDistMin < 100.0 or __fAltMax - __fAltMin < 35.0:
            if self.oArguments.debug:
                sys.stderr.write( "DEBUG[__process]: ABORT\n" )
            return

        # Attitude (climb/descent)
        # NOTE: This will be used to determine whether landing or take-off stall speed must be used
        __fHSpdMin = 9999999.0
        for __i in __lSplineRange:
            if __aHSpd[__i] < __fHSpdMin: __fHSpdMin = __aHSpd[__i]
        __aAtt = numpy.ones( __iSplineLength, numpy.int8 )
        # ... start by "descent"
        __iAtt = -1
        for __i in __lSplineRange:
            if __aHSpd[__i] - __fHSpdMin < 1.0:
                # ... horizontal speed has reached minimum; switch to "ground roll"
                __iAtt = 0
            elif __iAtt == 0:
                # ... after "ground roll", switch to "climb"
                __iAtt = 1
            __aAtt[__i] = __iAtt

        # Compute altitude correction
        # NOTE: GPS elevation data precision s***! We must thus correct:
        #        1. referential offset (e.g. WGS-84 vs AMSL elevation)
        #        2. data imprecisions
        #       We do this by:
        #        1. assuming we're *on* ground (AGL=0) when speed is 10% (error margin) below stall speed
        #        2. computing the mean altitude correction when 1. is satisfied
        #        3. using 2. when 1. is *not* satisfied
        #        4. spline-smoothing the results with weight factors that are:
        #            a. W=1 when 1. is satisfied
        #            b. W=1 when speed is 20% above stall speed
        #            c. W=0 in-between
        #       Then apply the correction and re-compute the vertical speed (that is the 2nd-pass mentioned above)
        __aAltCorr = numpy.zeros( __iSplineLength )
        __fAltCorr = 0.0
        __iAltCorr = 0
        for __i in __lSplineRange:
            __fAlt = __aAlt[__i]
            if __fAlt < 100.0 and \
              ( ( abs( __aVSpd[__i] ) < 1.0 and __aHSpd[__i] < 0.9*self.oArguments.stall_speed_landing ) or \
                (__aAtt[__i] == 1 and __aHSpd[__i] < 0.9*self.oArguments.stall_speed_takeoff ) or \
                __aHSpd[__i] < 0.9*self.oArguments.stall_speed_landing ):
                __aAltCorr[__i] = __fAlt
                __fAltCorr += __fAlt
                __iAltCorr += 1
        if __iAltCorr == 0:
            if self.oArguments.debug:
                sys.stderr.write( "DEBUG[__process]: Negative, Ghost Rider, the pattern is full!\n" )
                sys.stderr.write( "DEBUG[__process]: ABORT\n" )
            return
        __fAltCorr /= __iAltCorr
        if self.oArguments.debug:
            sys.stderr.write( "DEBUG[__process]: Mean altitude correction = %.1fm (N=%d)\n" % ( __fAltCorr, __iAltCorr ) )
        if __fAltCorr > 100.0:
            if self.oArguments.debug:
                sys.stderr.write( "DEBUG[__process]: Negative, Ghost Rider, the pattern is full!\n" )
                sys.stderr.write( "DEBUG[__process]: ABORT\n" )
            return
        for __i in __lSplineRange:
            if __fAlt >= 100.0 or \
              not ( ( abs( __aVSpd[__i] ) >= 1.0 and __aHSpd[__i] < 10.0 )  or \
                    ( __aAtt[__i] == 1 and __aHSpd[__i] < 0.9*self.oArguments.stall_speed_takeoff ) or \
                    __aHSpd[__i] < 0.9*self.oArguments.stall_speed_landing ):
                __aAltCorr[__i] = __fAltCorr
        # ... smoothing and derivation (speed)
        __aW3DCorr = numpy.zeros( __iSplineLength )
        for __i in __lSplineRange:
            if __fAlt < 100.0 and \
              ( ( abs( __aVSpd[__i] ) < 1.0 and __aHSpd[__i] < 10.0 ) or \
                ( __aAtt[__i] == 1 and __aHSpd[__i] < 0.9*self.oArguments.stall_speed_takeoff ) or \
                __aHSpd[__i] < 0.9*self.oArguments.stall_speed_landing ):
                __aW3DCorr[__i] = 1.0
            if abs( __aVSpd[__i] ) >= 2.5 or \
              ( __aAtt[__i] != 1 and __aHSpd[__i] > 1.2*self.oArguments.stall_speed_landing ) or \
              __aHSpd[__i] > 1.2*self.oArguments.stall_speed_takeoff:
                __aW3DCorr[__i] = 1.0
        __tTCK = interpolate.splrep( __aEpoch, __aAltCorr, k=3, w=__aW3DCorr, s=__iSplineLength*(__fSmoothingFactor3D*__fError3D)**2 )
        __aAltCorr = interpolate.splev( __aEpoch, __tTCK, der=0 )
        for __i in __lSplineRange:
            __aAlt[__i] -= __aAltCorr[__i]
        # ... NOTE: altitude and correction already have been smoothed; we shall not smooth any further (s=0)
        __tTCK = interpolate.splrep( __aEpoch, __aAlt, k=3, w=__aW3D, s=0 )
        __aVSpd = interpolate.splev( __aEpoch, __tTCK, der=1 )

        # Compute "Air Speed" (more or less)
        __aASpd = numpy.zeros( __iSplineLength )
        for __i in __lSplineRange:
            __aASpd[__i] = math.sqrt( __aHSpd[__i]**2 + __aVSpd[__i]**2 )


        # Detect "airborne" status
        # NOTE: This is the tricky part (given the imprecisions/errors on the altitude)
        __aAirborne = numpy.zeros( __iSplineLength, numpy.uint8 )
        for __i in __lSplineRange:
            # IF:
            # 1. we're definitely airborne
            # 2-3. we're not below stall speed
            # 4. altitude or (absolute) vertical speed are above threshold
            if __aAlt[__i] > 10.0 or \
              ( not ( ( __aAtt[__i] == 1 and __aASpd[__i] < self.oArguments.stall_speed_takeoff ) or \
                      __aASpd[__i] < self.oArguments.stall_speed_landing ) and \
                ( __aAlt[__i] > 1.0 or abs( __aVSpd[__i] ) > 1.0 ) ):
                __aAirborne[__i] = 1

        # Filter out data imprecisions/errors noise
        __aAirborne_clean = cv2.morphologyEx( __aAirborne, cv2.MORPH_CLOSE, self.aNoiseFilterKernel )
        __aAirborne_clean = cv2.morphologyEx( __aAirborne_clean, cv2.MORPH_OPEN, self.aNoiseFilterKernel )

        # Filter-out touch-'n-go data
        # NOTE: Data analysis window length MUST be above kernel length prevent morphological filtering artifacts
        if __iSplineLength > self.iTouchgoFilterLength:
            __aAirborne_touchgo = cv2.morphologyEx( __aAirborne_clean, cv2.MORPH_CLOSE, self.aTouchgoFilterKernel )
        else:
            __aAirborne_touchgo = __aAirborne_clean

        # Output detected events
        # NOTE: Touch-'n-go can not occur at the beginning/end of the analysis window
        for __i in range( 1, __iSplineLength ):
            if __aAirborne_clean[__i] != __aAirborne_clean[__i-1]:
                sys.stdout.write( "%s" % _sIdent )
                sys.stdout.write( "%s%s.%sZ" % ( self.oArguments.delimiter, \
                                                 time.strftime( '%Y-%m-%dT%H:%M:%S', time.gmtime( __aEpoch[__i] ) ), \
                                                 ( "%.3f" % math.modf( __aEpoch[__i] )[0])[2:] ) )
                sys.stdout.write( "%s%.6f" % ( self.oArguments.delimiter, __aLat[__i] ) )
                sys.stdout.write( "%s%.6f" % ( self.oArguments.delimiter, __aLon[__i] ) )
                sys.stdout.write( "%s%.1f" % ( self.oArguments.delimiter, self.__rwyele( __aLat[__i], __aLon[__i] ) ) )
                sys.stdout.write( "%s%.1f" % ( self.oArguments.delimiter, __aBrng[__i] ) )
                sys.stdout.write( "%s%.1f" % ( self.oArguments.delimiter, __aASpd[__i] ) )
                sys.stdout.write( "%s%.1f" % ( self.oArguments.delimiter, __aVSpd[__i] ) )
                if __aAirborne_clean[__i]:
                    sys.stdout.write( "%s%s" % ( self.oArguments.delimiter, 'AIRBORNE' ) )
                    if __i > self.iTouchgoFilterLength/2 and __aAirborne_touchgo[__i-1]:
                        sys.stdout.write( "%s%s" % ( self.oArguments.delimiter, 'TOUCHGO' ) )
                    else:
                        sys.stdout.write( "%s%s" % ( self.oArguments.delimiter, 'TAKEOFF' ) )
                else:
                    sys.stdout.write( "%s%s" % ( self.oArguments.delimiter, 'TOUCHDOWN' ) )
                    if __i < __iSplineLength - self.iTouchgoFilterLength/2 and __aAirborne_touchgo[__i+1]:
                        sys.stdout.write( "%s%s" % ( self.oArguments.delimiter, 'TOUCHGO' ) )
                    else:
                        sys.stdout.write( "%s%s" % ( self.oArguments.delimiter, 'LANDING' ) )
                if math.cos( ( __aBrng[__i] - self.fRwyHeading ) * DEG_2_RAD ) > 0.0:
                    sys.stdout.write( "%s%01d" % ( self.oArguments.delimiter, int( self.fRwyHeading/10.0 ) ) )
                    ( __fThrDist, __fThrAzim ) = trackRL( self.oArguments.runway_threshold_latitude_1, self.oArguments.runway_threshold_longitude_1, __aLat[__i], __aLon[__i] )
                    sys.stdout.write( "%s%.1f" % ( self.oArguments.delimiter, __fThrDist * abs( math.cos( ( __fThrAzim - self.fRwyHeading ) * DEG_2_RAD ) ) ) )
                    sys.stdout.write( "%s%.1f" % ( self.oArguments.delimiter, __fThrDist * abs( math.sin( ( __fThrAzim - self.fRwyHeading ) * DEG_2_RAD ) ) ) )
                else:
                    sys.stdout.write( "%s%01d" % ( self.oArguments.delimiter, int( self.fRwyHeading/10.0+18.0 ) ) )
                    ( __fThrDist, __fThrAzim ) = trackRL( self.oArguments.runway_threshold_latitude_2, self.oArguments.runway_threshold_longitude_2, __aLat[__i], __aLon[__i] )
                    sys.stdout.write( "%s%.1f" % ( self.oArguments.delimiter, __fThrDist * abs( math.cos( ( __fThrAzim - self.fRwyHeading ) * DEG_2_RAD ) ) ) )
                    sys.stdout.write( "%s%.1f" % ( self.oArguments.delimiter, __fThrDist * abs( math.sin( ( __fThrAzim - self.fRwyHeading ) * DEG_2_RAD ) ) ) )
                sys.stdout.write( "\n" )

        # DEBUG: plot interpolated data graphs (I love looking at those! :-) )
        if self.oArguments.debug:
            # ... compute GPS data
            __aDistGPS = numpy.zeros( __iDataLength )
            __aAltGPS = numpy.zeros( __iDataLength )
            for __i in __lDataRange:
                if __i>0: __aDistGPS[__i] = __aDistGPS[__i-1] + trackRL( _oGpsData.lLat[__i-1], _oGpsData.lLon[__i-1], _oGpsData.lLat[__i], _oGpsData.lLon[__i] )[0]
                __aAltGPS[__i] = _oGpsData.lEle[__i] - self.__rwyele( _oGpsData.lLat[__i], _oGpsData.lLon[__i] ) - __fAltCorr
            # ... plot data
            plot.plot( _oGpsData.lEpoch, __aDistGPS*0.1, color='b', linestyle='None', marker='o' )
            plot.plot( __aEpoch, __aDist*0.1, color='b' )
            plot.plot( _oGpsData.lEpoch, __aAltGPS, color='g', linestyle='None', marker='o' )
            plot.plot( __aEpoch, __aAlt, color='r' )
            plot.plot( __aEpoch, __aAltCorr, color='r', linestyle=':' )
            plot.plot( __aEpoch, __aASpd, color='m' )
            #plot.plot( __aEpoch, __aHAcc, color='m', linestyle=':' )
            plot.plot( __aEpoch, __aVSpd, color='c' )
            #plot.plot( __aEpoch, __aVAcc, color='c', linestyle=':' )
            plot.plot( __aEpoch, 20.0*__aAtt, color='y', linestyle=':' )
            plot.plot( __aEpoch, __aAirborne*self.oArguments.stall_speed_takeoff, color='k', linestyle=':' )
            plot.plot( __aEpoch, __aAirborne_clean*self.oArguments.stall_speed_landing, color='k' )
            plot.title( "%s: %s - %s" % ( _sIdent, time.strftime( '%Y-%m-%dT%H:%M:%S', time.gmtime( __aEpoch[0] ) ), time.strftime( '%Y-%m-%dT%H:%M:%S', time.gmtime( __aEpoch[__iSplineLength-1] ) ) ) )
            plot.legend( [ 'Dist. (GPS)', 'Dist.', 'Alt. (GPS)', 'Alt.', 'Alt. (corr.)', 'A.Spd', 'V.Spd', 'Attitude', 'Airborne (RAW)', 'Airborne' ], loc='best' )
            plot.show()


    #
    # Main
    #

    def main( self ):
        """
        Executes the GPS to Logbook data converter; returns a non-zero exit code in case of failure.
        """

        # Parse arguments
        __iReturn = self.__initArguments()
        if __iReturn:
            return __iReturn

        # Compute additional airfield parameters
        ( self.fRwyLat, self.fRwyLon ) = \
          midpointRL( self.oArguments.runway_threshold_latitude_1,
                      self.oArguments.runway_threshold_longitude_1,
                      self.oArguments.runway_threshold_latitude_2,
                      self.oArguments.runway_threshold_longitude_2 )
        ( self.fRwyLength, self.fRwyHeading ) = \
          trackRL( self.oArguments.runway_threshold_latitude_1,
                   self.oArguments.runway_threshold_longitude_1,
                   self.oArguments.runway_threshold_latitude_2,
                   self.oArguments.runway_threshold_longitude_2 )

        # Morphological filtering kernels
        # NOTE: Kernel length MUST be odd to prevent morphological filtering artifacts
        # ... noise filter
        self.iNoiseFilterLength = int( self.oArguments.noise_filter / self.oArguments.time_resolution )
        __iKLength = self.iNoiseFilterLength
        if __iKLength % 2 == 0: __iKLength += 1
        self.aNoiseFilterKernel = numpy.ones( __iKLength, numpy.uint8 )
        # ... touch-'n-go filter
        self.iTouchgoFilterLength = int( self.oArguments.touchgo_filter / self.oArguments.time_resolution )
        __iKLength = self.iTouchgoFilterLength
        if __iKLength % 2 == 0: __iKLength += 1
        self.aTouchgoFilterKernel = numpy.ones( __iKLength, numpy.uint8 )

        # Parse the DSV file
        # FORMAT: Ident,DateTime,Latitude[deg],Longitude[deg],Elevation[m],LatitudeError[m],LongitudeError[m],ElevationError[m]
        # NOTE: We don't use GPS-provide course data, since GPS do not get those "natively",
        #       but rather derive them from position data (the same way as we'll do here, elaborately,
        #       using splines first and second derivatives
        __oTimeEpochStart = parser.parse( '1970-01-01T00:00:00Z' )
        __fRefEle = ( self.oArguments.runway_threshold_elevation_1 + self.oArguments.runway_threshold_elevation_2 ) / 2.0
        __fRefDist = self.fRwyLength / 2.0
        __fRefHWidth = self.oArguments.runway_width / 2.0
        __dGpsData = {}
        for __lRow in csv.reader( iter( sys.stdin.readline, '' ), delimiter=self.oArguments.delimiter ):
            __iRowLength = len( __lRow )
            if __iRowLength == 0: continue
            if __lRow[0].strip().startswith( '#' ): continue
            if __iRowLength < 4 and not ( __iRowLength == 0 and __lRow[0].strip() ):
                sys.stderr.write( "WARNING: Invalid data; %s\n" % self.oArguments.delimiter.join( __lRow ) )
                continue

            # Retrieve geolocalization data
            ( __sIdent, __sTime, __sLat, __sLon, __sEle ) = tuple( __lRow )[:5]
            if not __sIdent or not __sTime or not __sLat or not __sLon or not __sEle:
                sys.stderr.write( "WARNING: Invalid data; %s\n" % self.oArguments.delimiter.join( __lRow ) )
                continue
            if __iRowLength >= 8:
                ( __sLatErr, __sLonErr, __sEleErr ) = tuple( __lRow )[5:8]
            else:
                ( __sLatErr, __sLonErr, __sEleErr ) = ( '0', '0', '0' )
            try:
                try:
                    __fEpoch = float( __sTime )
                except Exception:
                    __fEpoch = ( parser.parse( __sTime ) - __oTimeEpochStart ).total_seconds()
                __fLat = float( __sLat )
                __fLon = float( __sLon )
                __fEle = float( __sEle )
                __fLatErr = float( __sLatErr )
                __fLonErr = float( __sLonErr )
                __fEleErr = float( __sEleErr )
            except Exception:
                sys.stderr.write( "WARNING: Invalid data; %s\n" % self.oArguments.delimiter.join( __lRow ) )
                continue

            # Retrieve GPS data container
            if __dGpsData.has_key( __sIdent ):
                __oGpsData = __dGpsData[__sIdent]
            else:
                __oGpsData = CGpsData()
                __dGpsData[__sIdent] = __oGpsData

            # Compute (crude) course data
            __bPrev = False
            if __oGpsData.fEpochPrev > 0.0:
                ( __fDist, __fBrng ) = trackRL( __oGpsData.fLatPrev, __oGpsData.fLonPrev, __fLat, __fLon )
                try:
                    __fHSpd = __fDist / ( __fEpoch - __oGpsData.fEpochPrev )
                except Exception:
                    sys.stderr.write( "WARNING: Duplicated data; %s\n" % self.oArguments.delimiter.join( __lRow ) )
                    continue
                __fHSpd += self.oArguments.wind_speed * math.cos( ( __fBrng - self.oArguments.wind_direction ) * DEG_2_RAD )
                __bPrev = True
            __oGpsData.fEpochPrev = __fEpoch
            __oGpsData.fLatPrev = __fLat
            __oGpsData.fLonPrev = __fLon
            if not __bPrev:
                continue

            # Compute runway axis crossing angle
            __fAxisXAng = abs( __fBrng - self.fRwyHeading )
            if __fAxisXAng > 90.0:
                __fAxisXAng = abs( 180.0 - __fAxisXAng )

            # Detect whether point is worth considering
            ( __fRwyDist, __fRwyAzim ) = trackRL( self.fRwyLat, self.fRwyLon, __fLat, __fLon )
            __fRwyOffset = __fRwyDist * abs( math.sin( ( __fRwyAzim - self.fRwyHeading ) * DEG_2_RAD ) )
            # sys.stderr.write( "DEBUG[main]: %.1f, %.1f, %.1f, %.1f, %.1f\n" % \
            #                   ( __fHSpd, __fAxisXAng, __fEle, __fRwyDist, __fRwyOffset ) )
            # IF:
            # 1. ship is moving
            # 2. below the decision altitude
            # 3-9. close enough to (or *on*) the runway
            if __fHSpd > 1.0 and \
              __fEle < __fRefEle + 300.0 and \
              __fRwyOffset < __fRefHWidth + 250.0 and \
              __fRwyDist < __fRefDist + 750.0 and \
              ( __fRwyDist > __fRefDist or \
                __fHSpd > 10.0 or \
                (  __fRwyOffset < __fRefHWidth + 10.0 and __fAxisXAng < 60.0 ) ):
                # sys.stderr.write( "DEBUG[main]: TRIGGER\n" )
                __oGpsData.iTrigCount += 1
            else:
                __oGpsData.iTrigCount -= 1
            if __oGpsData.iTrigCount >= 5:
                __oGpsData.iTrigCount = 5

            # Store data
            # NOTE: No actual processing/detection takes place here
            #       We merely store "worthy" data and wait until enough of those have
            #       been accumulated to launch the actual processing/detection algorithm
            # IF:
            # 1. worthy data trigger has been activated
            # 2. time gap is below analysis window length
            if __oGpsData.iTrigCount > 0 and \
              ( __oGpsData.iDataLength == 0 or __fEpoch - __oGpsData.lEpoch[0] < self.oArguments.analysis_length ):
                # sys.stderr.write( "DEBUG[main]: %.1f, %.1f, %.1f, %.1f, %.1f\n" % \
                #                 ( __fHSpd, __fAxisXAng, __fEle, __fRwyDist, __fRwyDist * abs( math.sin( ( __fRwyAzim - self.fRwyHeading ) * DEG_2_RAD ) ) ) )
                __oGpsData.lEpoch.append( __fEpoch )
                __oGpsData.lLat.append( __fLat )
                __oGpsData.lLon.append( __fLon )
                __oGpsData.lEle.append( __fEle )
                __oGpsData.lLatErr.append( __fLatErr )
                __oGpsData.lLonErr.append( __fLonErr )
                __oGpsData.lEleErr.append( __fEleErr )
                __oGpsData.iDataLength += 1

            # Process
            # IF:
            # 1. data (from the same analysis window) haven't already been processed
            # 2+3. enough data are available AND
            # 4. analysis window length is reached OR
            # 5. or worthy data are no longer available
            if not __oGpsData.bDataProcessed and \
              __oGpsData.iDataLength >= 10 and \
              __oGpsData.lEpoch[__oGpsData.iDataLength-1] - __oGpsData.lEpoch[0] >= self.oArguments.noise_filter and \
              ( __oGpsData.lEpoch[__oGpsData.iDataLength-1] - __oGpsData.lEpoch[0] >= self.oArguments.analysis_length or \
                __oGpsData.iTrigCount <= 0 ):
                self.__process( __sIdent, __oGpsData )
                __oGpsData.bDataProcessed = True

            # Stop accumulating and clear data ("untrigger")
            # IF: worthy data trigger has starved
            if __oGpsData.iTrigCount <= 0:
                __oGpsData.reset()

        # Process (end of file)
        for __sIdent in __dGpsData.keys():
            __oGpsData = __dGpsData[__sIdent]
            # IF:
            # 1. data (from the same analysis window) haven't already been processed
            # 2+3. enough data are available AND
            if not __oGpsData.bDataProcessed and \
              __oGpsData.iDataLength >= 10 and \
              __oGpsData.lEpoch[__oGpsData.iDataLength-1] - __oGpsData.lEpoch[0] >= self.oArguments.noise_filter:
              self.__process( __sIdent, __oGpsData )


#------------------------------------------------------------------------------
# MAIN
#------------------------------------------------------------------------------

if __name__ == '__main__':
    oGps2Logbook = CGps2Logbook()
    sys.exit( oGps2Logbook.main() )
